{
  "title": "Implementing transform streams",
  "cells": [
    {
      "type": "markdown",
      "data": "## Duplex streams\nUseful for describing an entity that is both a data source and a data destination.\n\nDuplex streams inherit the methods of both `stream.Readable` and `stream.Writable` meaning we can `read()` or `write()` data, or listen for both the `readable` and `drain` events.\n\n## Transform streams\nSpecial kind of Duplex stream that is designed for handling data transformations.\n\nIn a simple Duplex stream, tgere is no immediate relationship between the data read from the stream and the data written into it\n\n### Implementing Transform streams\n`_transform()` and `_flush()` must be implemented\n\n`_transform(chunk, encoding, callback)`\n\nUnlike the `WritableStream`, the data is not written to an underlying resource, it is pushed into an internal buffer using `push()`.\n\n`flush(callback)`\n\nOnly takes a callback that is invokes when all the operations are complete. \n\nIt is the final opportunity to push any remaining data before completely ending the stream.\n\n### Example\n\n```js\n\"use strict\";\n\nconst stream = require('stream');\nconst util = require('util');\n\nclass ReplaceStream extends stream.Transform {\n  constructor(searchString, replaceString) {\n    super();\n    this.searchString = searchString;\n    this.replaceString = replaceString;\n    this.tailPiece = '';\n  }\n\n  _transform(chunk, encoding, callback) {\n    const pieces = (this.tailPiece + chunk)         //[1]\n      .split(this.searchString);\n    const lastPiece = pieces[pieces.length - 1];\n    const tailPieceLen = this.searchString.length - 1;\n\n    debugger;\n    this.tailPiece = lastPiece.slice(-tailPieceLen);\n    pieces[pieces.length - 1] = lastPiece.slice(0,-tailPieceLen);\n\n    this.push(pieces.join(this.replaceString));       //[3]\n    callback();\n  }\n\n  _flush(callback) {\n    this.push(this.tailPiece);\n    callback();\n  }\n}\n\nmodule.exports = ReplaceStream;\n```"
    }
  ]
}