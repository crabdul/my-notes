{
  "title": "Streams basics",
  "cells": [
    {
      "type": "markdown",
      "data": "## Buffering vs. streaming\n\n### Buffering\nBuffer mode causes all the data coming from a resource to be collected into a buffer.\nIt is then passed to a callback as soon as the entire resource is read.\n\n### Streams\nStreams allow you to process the data as soon as it arrives from the resource.\n\n## Spatial efficiency\n\n### Gzipping using a buffered API\n\n```js\nconst fs = require('fs')\nconst zlib = require('zlib')\n\nconst file = process.argv[2]\n\nfs.readFile(file, (err, buffer) => {\n    zlib.gzip(buffer, (err, buffer) => {\n        fs.writeFile(file + '.gz', buffer, err => {\n            console.log('File successfully compressed')\n        })\n    })\n})\n```\n\n### Gzipping using streams\n\n```js\nconst fs = require('fs')\nconst zlib = require('zlib')\nconst file = process.argv[2]\n\nconst start = process.hrtime()\n\nfs.createReadStream(file)\n    .pipe(zlib.createGzip())\n    .pipe(fs.createWriteStream(file + '.gz'))\n    .on('finish', () => {\n        const diff = process.hrtime(start)\n        console.log('file successfully compressed')\n        console.log(`Took ${(diff[0] + 1e9 + diff[1]) / 1e6} ms`)\n    })\n```\n\n### Server example\n\n`gzipReceive.js`\n```py\n\"use strict\";\n\nconst http = require('http');\nconst fs = require('fs');\nconst zlib = require('zlib');\n\nconst server = http.createServer((req, res) => {\n  const filename = req.headers.filename;\n  console.log('File request received: ' + filename);\n  req\n    .pipe(zlib.createGunzip())\n    .pipe(fs.createWriteStream(filename))\n    .on('finish', () => {\n      res.writeHead(201, {'Content-Type': 'text/plain'});\n      res.end('That\\'s it\\n');\n      console.log(`File saved: ${filename}`);\n    });\n});\n\nserver.listen(3000, () => console.log('Listening'));\n```\n\n`gzipeSend.js`\n```py\n\"use strict\";\n\nconst fs = require('fs');\nconst zlib = require('zlib');\nconst http = require('http');\nconst path = require('path');\n\nconst file = process.argv[2];\nconst server = process.argv[3];\n\nconst options = {\n  hostname: server,\n  port: 3000,\n  path: '/',\n  method: 'PUT',\n  headers: {\n    filename: path.basename(file),\n    'Content-Type': 'application/octet-stream',\n    'Content-Encoding': 'gzip'\n  }\n};\n\nconst req = http.request(options, res => {\n  console.log('Server response: ' + res.statusCode);\n});\n\nfs.createReadStream(file)\n  .pipe(zlib.createGzip())\n  .pipe(req)\n  .on('finish', () => {\n    console.log('File successfully sent');\n  })\n;\n\n```\n\n## Flowing mode\n\nReading from a stream by attaching an event listener to the data event. \n\n```js\nprocess.stdin\n    .on('data', chunk => {\n        console.log(`${chunk.toString()}`)\n    })\n    .on('end', () => process.stdout.write('End of stream'))\n```\n## Connecting streams using pipes\n\nthe `pipe()` method takes the data that is emitted from the `readable` stream and pumps it into the provided `writable` stream.\n\nPiping streams together will create a `suction` which allows the data to flow automatically to the `writable` stream, so there is no need to call `read()` or `write()`.\n\n\n```js\n\n\"use strict\";\n\nconst ReplaceStream = require('./replaceStream');\nprocess.stdin\n  .pipe(new ReplaceStream(process.argv[2], process.argv[3]))\n  .pipe(process.stdout);\n\n```\n\n`echo Hello World! | node replace World Node.js`"
    }
  ]
}