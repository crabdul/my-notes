{
  "title": "Controlled and uncontrolled inputs",
  "cells": [
    {
      "type": "markdown",
      "data": "These two terms controlled and uncontrolled are very often used in the context of forms management. controlled input is an input that gets its value from a single source of truth. For example the App component below has a single <input> field which is controlled:\n\n```js\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { value: 'hello' };\n  }\n  render() {\n    return <input type='text' value={ this.state.value } />;\n  }\n};\n```\n\nThe result of this code is an input element that we can focus but can't change. It is never updated because we have a single source of truth - the App's component state. To make the input work as expected we have to add an onChange handler and update the state (the single source of truth). Which will trigger a new rendering cycle and we will see what we typed.\n\n```js\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { value: 'hello' };\n    this._change = this._handleInputChange.bind(this);\n  }\n  render() {\n    return (\n      <input\n        type='text'\n        value={ this.state.value }\n        onChange={ this._change } />\n    );\n  }\n  _handleInputChange(e) {\n    this.setState({ value: e.target.value });\n  }\n};\n```\n\nOn the opposite side is the uncontrolled input where we let the browser handle the user's updates. We may still provide an initial value by using the defaultValue prop but after that the browser is responsible for keeping the state of the input.\n\n```js\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { value: 'hello' };\n  }\n  render() {\n    return <input type='text' defaultValue={ this.state.value } />\n  }\n};\n```\n\nThat <input> element above is a little bit useless because the user updates the value but our component has no idea about that. We then have to use Refs to get access to the actual element.\n\n```js\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { value: 'hello' };\n    this._change = this._handleInputChange.bind(this);\n  }\n  render() {\n    return (\n      <input\n        type='text'\n        defaultValue={ this.state.value }\n        onChange={ this._change }\n        ref={ input => this.input = input }/>\n    );\n  }\n  _handleInputChange() {\n    this.setState({ value: this.input.value });\n  }\n};\n```\n\nThe ref prop receives a string or a callback. The code above uses a callback and stores the DOM element into a local variable called input. Later when the onChange handler is fired we get the new value and send it to the App's state.\n\nUsing a lot of refs is not a good idea. If it happens in your app consider using controlled inputs and re-think your components."
    }
  ]
}