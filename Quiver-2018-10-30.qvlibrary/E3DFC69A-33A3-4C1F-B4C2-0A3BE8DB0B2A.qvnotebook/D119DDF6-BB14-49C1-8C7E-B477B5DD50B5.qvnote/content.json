{
  "title": "django.forms.Form",
  "cells": [
    {
      "type": "markdown",
      "data": "A form must specify\n\n1. `<input>` elements\n2. _where_: the URL to which the data should be sent\n3. _how_: the HTTP method the data should be retured by"
    },
    {
      "type": "markdown",
      "data": "## GET and POST\n\n### POST\nUsed for requests that make changes in the database\n\n### GET \n\nBundles the submitted data into a string, and uses this to compose a URL.\n\ne.g\n```\nhttps://docs.djangoproject.com/search/?q=forms&release=1.\n```\n\nonly for requests that do not affect the state of the system\n\n## The django Form class\n\nIn a similar way that a model class's fields map to database fields, a form class' fields map to HTML form `<input>` elements.\n\nA form's fields are themselves classes.\n\nA form field is represented to a user in the browser as an HTML \"widget\"\n\n### Example\n\n`forms.py`\n\n```py\nfrom django import forms\n\nclass NameForm(forms.Form):\n    your_name = forms.CharField(label='Your name', max_length=100)\n\n```\n\n`views.py`\n```py\n\nfrom django.http import HttpResponseRedirect\nfrom django.shortcuts import render\n\nfrom .forms import NameForm\n\ndef get_name(request):\n    # if this is a POST request we need to process the form data\n    if request.method == 'POST':\n        # create a form instance and populate it with data from the request:\n        form = NameForm(request.POST)\n        # check whether it's valid:\n        if form.is_valid():\n            # process the data in form.cleaned_data as required\n            # ...\n            # redirect to a new URL:\n            return HttpResponseRedirect('/thanks/')\n\n    # if a GET (or any other method) we'll create a blank form\n    else:\n        form = NameForm()\n\n    return render(request, 'name.html', {'form': form})\n```\n\n`template.html`\n\n```py\n\n<form action=\"/your-name/\" method=\"post\">\n    {% csrf_token %}\n    {{ form }}\n    <input type=\"submit\" value=\"Submit\">\n</form>\n```\n"
    },
    {
      "type": "markdown",
      "data": "## Form and field validation\n\nNormally, cleaning methods are called when `is_valid()` method is called on the form.\n\nCleaning methods should raise `ValidationError` if the data it's processing is invalid. \nOtherwise, the method returns cleaned data as a Python object.\n\n\n### Validation steps\n\n#### `to_python()`\n\nThe `to_python()` method on a `Field` is the first step in every validation.\nThe value is coerced to a correct datatype and raise `ValidationError` if that isn't possible.\n\nE.g \nA `FloatField` will turn the data into a Python `float` or raise a `ValidationError`. \n\n#### `validate()`\n\nMethod on a `Field` that handles field-specific validation that is not suitable for a validator. It takes a value that has been coerced to a correct datatype and raises `ValidationError` on any error. \n\nThis method does not return anything and shouldn't alter the value.\n\n#### `run_validators()`\n\nRuns all the field's validators and aggregates all the errors into a single `ValidationError`\n\n#### `clean()`\n\nCalls all the above and returns the cleaned data\n\n### Using validation in practice\n\n#### Using validators\n\nA validator is a callable object or function that takes a value and simply returns nothing if the value is valid or raises a `ValidationError` if not. \n\n```py\n\nfrom django.core import validators\nfrom django.forms import CharField\n\nclass SlugField(CharField):\n    default_validators = [validators.validate_slug]\n    \n```\n\n```py\nslug = forms.SlugField()\n```\n\nis equivalent to \n\n```py\nslug = forms.CharField(validators=[validators.validate_slug])\n```\n\n#### Form field default cleaning\n\ndefine your own `to_python()` and `validate()`\n\n#### Cleaning a specific field attribute\n\nUsed when we don't want to put a validation on a general `Field` class.\n\nE.g \n```py\ndef clean_name_of_field(self):\n    ...\n```\n\n#### Cleaning and validating fields that depend on each other\n\ndefine your own `clean()`\n\nAll the individual field clean methods will have run so `self.cleaned_data`\nwill be populated with any data that has survived so far.\n\n```py\n\n    def clean(self):\n        super().clean()\n        cc_myself = self.cleaned_data.get(\"cc_myself\")\n        subject = self.cleaned_data.get(\"subject\")\n\n        if cc_myself and subject:\n            if \"help\" not in subject:\n                raise forms.ValidationError(\n                    \"Did not send for 'help' in the subject despite \"\n                    \"CC'ing yourself.\"\n                )\n\n```\n\n## Django forms in django shell\n\n**Aside**\n\n`unbound` - no data in the form\n\n**/Aside**\n\n```py\n\n(env) C:\\Users\\Q\\TGDB\\django_project>python manage.py shell\nPython 3.4.4 (v3.4.4:737efcadf5a6, Dec 20 2015, 20:20:57) [MSC v.1600 64 bit (AM\nD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n(InteractiveConsole)\n>>> from blog.forms import AuthorForm\n>>> f = AuthorForm()\n>>>\n```\n\n```py\n>>>\n>>> f.is_bound\nFalse\n>>>\n```\n\n```py\n>>>\n>>> f.is_valid()\nFalse\n>>>\n```\n\nIf `is_bound` is `False`, then `is_valid()` will always return `False`\n\n### Accessing cleaned data\n\nAfter the `is_valid()` Form method is called, the `cleaned_data` attribute returns the valid data.\nIf it is called before, it will return an `AttributeError`\n\n```py\n>>> data = {\n... 'your_name': 'crabdul'\n... }\n>>> data\n{'your_name': 'crabdul'}\n>>> filledForm = NameForm(data)\n>>> filledForm.is_bound\nTrue\n>>> filledForm.is_valid()\nTrue\n>>>\n>>> filledForm.cleaned_data\n{'your_name': 'crabdul'}\n```"
    }
  ]
}