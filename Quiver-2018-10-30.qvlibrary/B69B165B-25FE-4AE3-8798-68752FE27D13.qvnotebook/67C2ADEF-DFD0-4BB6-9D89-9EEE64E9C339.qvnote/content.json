{
  "title": "Redux-form-test",
  "cells": [
    {
      "type": "markdown",
      "data": "[github](https://github.com/tylercollier/redux-form-test)"
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "code",
      "language": "javascript",
      "data": "import ContactFormComponent, { renderTextInput } from '../../app/ContactFormComponent'\nimport React from 'react'\nimport { SubmissionError } from 'redux-form'\n\n// See README for discussion of chai, enzyme, and sinon\nimport chai, { expect } from 'chai'\nimport { shallow } from 'enzyme'\nimport chaiEnzyme from 'chai-enzyme'\nimport sinon from 'sinon'\n\nchai.use(chaiEnzyme())\n\n// In this file we're doing unit testing of our component, which means it\n// really has nothing to do with Redux-Form at this point. We can pass in our\n// own props (e.g. `submitting`) and make sure our form renders as we expect.\n\ndescribe(\"ContactFormComponent\", () => {\n\tlet subject = null\n\tlet submitting, touched, error, reset, onSave, onSaveResponse, handleSubmit\n\tbeforeEach(() => {\n\t\tsubmitting = false\n\t\ttouched = false\n\t\terror = null\n\t\treset = sinon.spy()\n\t\tonSaveResponse = Promise.resolve()\n\t\thandleSubmit = fn => fn\n\t})\n\tconst buildSubject = () => {\n\t\tonSave = sinon.stub().returns(onSaveResponse)\n\t\tconst props = {\n\t\t\tonSave,\n\t\t\tsubmitting: submitting,\n\t\t\t// The real redux form has many properties for each field,\n\t\t\t// including onChange and onBlur handlers. We only need to provide\n\t\t\t// the ones that will change the rendered output.\n\t\t\tfields: {\n\t\t\t\tfirstName: {\n\t\t\t\t\tvalue: '',\n\t\t\t\t\ttouched: touched,\n\t\t\t\t\terror: error\n\t\t\t\t}\n\t\t\t},\n\t\t\thandleSubmit,\n\t\t\treset\n\t\t}\n\t\treturn shallow(<ContactFormComponent {...props}/>)\n\t}\n\n\t// Here we show we can test asychronous actions triggered by our form.\n\tit(\"calls reset after onSave\", () => {\n\t\tsubject = buildSubject()\n\t\tsubject.find('form').simulate('submit')\n\t\texpect(onSave.callCount).to.equal(1)\n\t\t// This onSaveResponse isn't the 'real' response. But using .then()\n\t\t// with it works here because it enforces that we run our expect check\n\t\t// AFTER all the form submit logic has run.\n\t\treturn onSaveResponse.then(() => {\n\t\t\texpect(reset.callCount).to.equal(1)\n\t\t})\n\t})\n\n\t// This is a very simple test, making sure that if we pass in a certain\n\t// prop value, our form renders appropriately.\n\tcontext(\"when submitting\", () => {\n\t\tit(\"shows a wait message while submitting\", () => {\n\t\t\tsubmitting = true\n\t\t\tsubject = buildSubject()\n\t\t\tconst icon = subject.find('button[type=\"submit\"]')\n\t\t\texpect(icon).to.have.text('Submitting (takes 1 s)')\n\t\t})\n\n\t\tcontext('when server returns an error', () => {\n\t\t\tbeforeEach(() => {\n\t\t\t\tonSaveResponse = Promise.reject('some rejection')\n\t\t\t})\n\n\t\t\tit(\"throws a SubmissionError on error in the form submit handler\", () => {\n\t\t\t\tlet promiseReturnedFromFormHandler\n\t\t\t\thandleSubmit = fn => {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\t// In this test, we know arguments will be empty because we\n\t\t\t\t\t\t// control it in our test when we simulate the submit, and\n\t\t\t\t\t\t// don't pass it any arguments. But it's just good practice to\n\t\t\t\t\t\t// pass them along.\n\t\t\t\t\t\tpromiseReturnedFromFormHandler = fn(arguments)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubject = buildSubject()\n\t\t\t\tsubject.find('form').simulate('submit')\n\t\t\t\texpect(onSave.callCount).to.equal(1)\n\t\t\t\treturn promiseReturnedFromFormHandler.then(() => {\n\t\t\t\t\tthrow new Error(\"Submission error should have been checked but wasn't\")\n\t\t\t\t}).catch(error => {\n\t\t\t\t\texpect(error).to.be.instanceof(SubmissionError)\n\t\t\t\t})\n\t\t\t})\n\n\t\t\tit(\"alternative approach to previous test - throws a SubmissionError on error in the form submit handler\", () => {\n\t\t\t\t// In this alternative approach, we're calling the component's\n\t\t\t\t// submit handler directly. This is probably fine for simple\n\t\t\t\t// components, but I worry if the component is more complex.\n\t\t\t\t// The reason I'm showing this way is to show the use of\n\t\t\t\t// enzyme's .instance() method.\n\t\t\t\tsubject = buildSubject()\n\t\t\t\tconst promiseReturnedFromFormHandler = subject.instance().mySubmit({ firstName: 'somename' })\n\t\t\t\treturn promiseReturnedFromFormHandler.then(() => {\n\t\t\t\t\tthrow new Error('Should not hit this then block - test was set up incorrectly')\n\t\t\t\t}).catch(error => {\n\t\t\t\t\texpect(error).to.be.instanceof(SubmissionError)\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t})\n\n})\n\n// renderTextInput is a stateless functional component, aka just a method that\n// returns a React element, so it's trivial to test. We export it from the\n// ContactFormComponent file. It could be named whatever we want, but it\n// should be named based on what type of input component it creates, since you\n// would create a similar function for each type of component you need to\n// render. If you look in renderTextInput, it outputs an <input/>, but you\n// would need a different method if you wanted to output a <select/>,\n// <textarea>, or something more complex like a composite component with many\n// parts, e.g. if you're using react-bootstrap.\ndescribe('renderTextInput', () => {\n\tlet subject\n\tcontext(\"when in an error state\", () => {\n\t\tit(\"renders an error message for the input\", () => {\n\t\t\tconst input = { name: 'firstName', value: '' }\n\t\t\tconst label = 'First name'\n\t\t\tconst meta = { touched: true, error: 'Required' }\n\t\t\tconst element = renderTextInput({ input, label, meta })\n\t\t\tsubject = shallow(element)\n\t\t\tconst firstNameHelpBlock = subject.find('.help-block').first()\n\t\t\texpect(firstNameHelpBlock).to.exist\n\t\t\texpect(firstNameHelpBlock.text()).to.equal('Required')\n\t\t})\n\t})\n})"
    }
  ]
}